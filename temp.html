
    <input name="GIMItemConfig:txtItemImperialLength:txtNumeric" type="text" value="44.4881" maxlength="12" id="GIMItemConfig_txtItemImperialLength_txtNumeric" class="flatbox"
           onkeypress="CheckNumeric()"
           onchange="subConvertINtoC(this, 'GIMItemConfig_txtItemMetricLength_txtNumeric');
                     subCalcItemCube()"
           onblur="CheckNValue(this,false)">


<input name="GIMItemConfig:txtItemMetricWeight:txtNumeric"
    onkeypress="CheckNumeric()" 
    onchange="subConvertKGStoLBS(this, 'GIMItemConfig_txtItemImperialWeight_txtNumeric');
        subCalcCaseCube();"
    onblur="CheckNValue(this, false)">




$(document).ready(function () {
        $("#btnExport").click(function () {
            $("#tblExport").btechco_excelexport({
                containerid: "tblExport"
               , datatype: $datatype.Table
            });
        });
    });


<script>

    var ele; // I dunno, an var specially for temporary document creation.

    // Global canvas variables
    var Package, MCase;
    Package.setSize(w, h);
    MCase.setSize(w, h);
    var w = 400, h = 200;
    var pkgCanvas = document.getElementById('pkgCanvas');
    var caseCanvas = document.getElementById('caseCanvas');

    // Simple objects to store the variables
    var package_CM, package_IN, mCase_CM, mCase_IN;
    var package_CM = {
        width: 0,
        depth: 0,
        height: 0,
        cube: 0
    };

    mCase_IN = mCase_CM = package_IN = package_CM;

    //TEST
    //console.log("RoundToNearest:" + RoundToNearest(19999.99));
    //package.width = package.depth = package.height = 50;
    //var itemCube = RoundToNearest(parseFloat((package.width * package.depth * package.height) / 12));
    //console.log(itemCube);
    //itemCube = ToFixed(RoundToNearest(itemCube), 4);
    //console.log(itemCube);


    // All editable inputs will recalculated Imperial to Metric or vice versa on their respective pair.
    // And recalculates the cube.
    // TODO: redraw the canvas -> or resave an image and reload page to show the change.
    $('.cell').on('change', function () {
        console.log("DEBUG: Inside onchange.");

        // Detects which input is changed and updates the respective object values.
        switch (this.name) {
            // PACKAGE : IMPERIAL
            //case 'pkgW_CM', 'pkgD_CM', 'pkgH_CM':
            //subConvertCMtoIN();
            case 'pkgW_CM':
                package_CM.width = $('#pkgW_CM').val();
                break;
            case 'pkgD_CM':
                package_CM.depth = $('#pkgD_CM').val();
                break;
            case 'pkgH_CM':
                package_CM.height = $('#pkgH_CM').val();
                break;

                // PACKAGE : METRIC


                // MASTER CASE : IMPERIAL
                //case 'masterW_IN', 'masterD_CM', 'masterH_CM':
                //subConvertINtoCM();
            case 'masterW_IN':
                mCase_CM.width = $('#masterW_IN').val();
                break;
            case 'masterD_CM':
                mCase_CM.depth = $('#masterD_CM').val();
                break;
            case 'masterH_CM':
                mCase_CM.height = $('#masterH_CM').val();

                // MASTER CASE : IMPERIAL


            default:
                break;
        }

        // Recalculates the cube when the inputs gets changed.
        if (package_CM.width != 0 && package_CM.depth != 0 && package_CM.height != 0) {
            var itemCube = RoundToNearest(parseFloat((package_CM.width * package_CM.depth * package_CM.height) / 1000000));
            // Extra: Round to 4 places max, but if only necessary:
            // original: Math.round(num * 100) / 100;
            // itemCube = Math.round((itemCube + 0.00001) * 10000) / 10000
            itemCube = RoundToNearest(itemCube).toFixed(4);
            document.getElementById('pkgC_M').value = itemCube;
            package_CM.cube = itemCube;
        }


        function prepareQtyCover() {
            cover.style.display = "inline";
            hide.style.display = "none";
        }
        // Magic stuff where when the qty input is clicked, it switch to a split input form
        // that display x * y value that equals the qty
        // It is 6(2*3) by default
        // TODO: smart calculation determine which config formation is optimal (via smaller cubic value?)
        function setQtyBy() {
            var cover = document.getElementById('qtyByCover');
            var hide = document.getElementById('qtyByHidden');

            if (cover.style.display == "inline" && hide.style.display == "none") {
                cover.style.display = "none";
                hide.style.display = "inline";
            }
            else if (cover.style.display == "none" && hide.style.display == "inline") {
                cover.style.display = "inline";
                hide.style.display = "none";
            }
        };

    });


    // Modifier buttons: click to switch between i) +1.5, +1.5, +2; ii) +2, +2, +2.5
    // TODO: A second button let user enters other vales (use pop-up window?)
    //var modValues = [1.5, 2, 2.5];
    //var modOpt = document.getElementById('modOpt');
    //var flag = 1;

    //ele = document.createElement('div');
    //ele.innerHTML = modValues[flag];
    //modOpt.appendChild(ele);
    //ele = document.createElement('div');
    //ele.innerHTML = modValues[flag];
    //modOpt.appendChild(ele);
    //ele = document.createElement('div');
    //ele.innerHTML = modValues[flag + 1];
    //modOpt.appendChild(ele);

    //ele = document.createElement('button');
    //ele.setAttribute('name', 'modBtn');
    //ele.setAttribute('id', 'modBtn');
    //ele.setAttribute('class', 'gemmyBorder');
    //ele.setAttribute('onclick', function () {
    //    flag = 1 - flag;
    //});
    //modOpt.appendChild(ele);

    //ele = 0; // clear ele

    (function () {
        if (pkgCanvas.getContext && caseCanvas.getContext) {
            Package = new CanvasForm(pkgCanvas, pkgCanvas.getContext('2d'));

            Package.c.save();
            Package.c.fillStyle = "rgb(50,50,50)";
            Package.c.fillRect(0, 0, w, h);
            Package.c.restore();
            //Package.setColor("rgb(50,50,250)");

            MCase = new CanvasForm(caseCanvas, caseCanvas.getContext('2d'));
            render();
            //setInterval(render, 30);

        }
        else { alert('Cannot get canvas context'); }

    })();

    var angle = 75;
    function render() {
        var t = [];

        //Package.c.clearRect(0, 0, w, h);
        //MCase.c.clearRect(0, 0, w, h);

        for (var i = 0; i < axis_vertices.length; i++) {
            var v = axis_vertices[i];
            var r = v.rotateX(angle).rotateY(angle).rotateZ(angle);
            var p = r.project(w, h, 128, 3.5);
            t.push(p);
        }

        Package.c.save();
        // Origin point for reference
        drawPoint(Package.c, t[0].x, t[0].y, 3, "black");

        // for each axis: which are 3 of them
        drawLine(Package.c, t[0], t[1], 1, red);
        drawLine(Package.c, t[0], t[2], 1, green);
        drawLine(Package.c, t[0], t[3], 1, blue);
        Package.c.restore();

        angle += 2;
    }


    //$('#saveAsExcelBtn').on('click', function () {
    //    alert("Excel");
    //});

    // I dunno man, too hard?
    //$('#saveScreenBtn').on('click', function () {
    //    alert('Screenshot');
    //});
</script>